b<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Way to Rome</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html,body,#map { height:100%; margin:0; }
    .topbar {
      position: absolute; left:10px; top:10px; z-index:1000;
      background: rgba(255,255,255,0.9); padding:8px 10px; border-radius:6px;
      font-family:system-ui,Segoe UI,Roboto; font-size:14px;
    }
    button { margin-left:6px; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="topbar">
    Click anywhere on the map (or use geolocation) → follow the road to Rome.
    <button id="locBtn">Use my location</button>
    <button id="clearBtn">Clear</button>
  </div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
  // === CONFIG ===
  // Rome coordinates — city center (can be tuned)
  const ROME = { lat: 41.902782, lon: 12.496366 };
  // OSRM public server endpoints (example); for production consider self-host or paid API
  const OSRM_BASE = "https://router.project-osrm.org";
  // === MAP INIT ===
  const map = L.map('map').setView([20, 0], 2);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19, attribution: '© OpenStreetMap'
  }).addTo(map);
  const romeMarker = L.marker([ROME.lat, ROME.lon]).addTo(map).bindPopup("Rome (city center)").openPopup();
  let userMarker, routeLayer, fallbackLayer;
  // Helper: clear layers
  function clear() {
    if (userMarker) { map.removeLayer(userMarker); userMarker = null; }
    if (routeLayer) { map.removeLayer(routeLayer); routeLayer = null; }
    if (fallbackLayer) { map.removeLayer(fallbackLayer); fallbackLayer = null; }
  }
  document.getElementById('clearBtn').onclick = clear;
  // Click to select start
  map.on('click', async (e) => {
    await handlePoint(e.latlng.lat, e.latlng.lng);
  });
  // Geolocation button
  document.getElementById('locBtn').onclick = () => {
    if (!navigator.geolocation) return alert("Geolocation not supported.");
    navigator.geolocation.getCurrentPosition(
      pos => handlePoint(pos.coords.latitude, pos.coords.longitude),
      err => alert("Couldn't get location: " + err.message)
    );
  };
  // Main flow: snap to road -> request route -> draw or fallback
  async function handlePoint(lat, lon) {
    clear();
    userMarker = L.marker([lat, lon]).addTo(map).bindPopup("Selected point").openPopup();
    map.setView([lat, lon], 6);
    try {
// --- CUSTOM VIRTUAL BRIDGES ---
const BERING_W = [-168.95, 65.78]; // Alaska
const BERING_E = [169.04, 65.78];  // Russia
const ALSALAM_W = [32.295, 30.605]; // Africa (Egypt)
const ALSALAM_E = [32.335, 30.605]; // Asia (Sinai)
// 1) Snap to nearest road (OSRM nearest)
      const nearestResp = await fetch(`${OSRM_BASE}/nearest/v1/driving/${lon},${lat}?number=1`);
      if (!nearestResp.ok) throw new Error("Nearest API failed");
      const nearestJson = await nearestResp.json();
      if (!nearestJson.waypoints || nearestJson.waypoints.length === 0) {
        throw new Error("No road nearby to snap to.");
      }
      const snapped = nearestJson.waypoints[0].location; // [lon, lat]
      const snappedLat = snapped[1], snappedLon = snapped[0];
      // show snapped marker
      const snappedMarker = L.circleMarker([snappedLat, snappedLon], { radius:6, color:'green' })
        .addTo(map).bindPopup("Snapped to nearest road").openPopup();
// Define key ferry connectors
const FERRIES = {
  // Al Salam Bridge ferry (Africa ↔ Asia)
  AFRICA_EURASIA: {
    entry: [32.31, 30.59],  // near Ismailia (Africa side)
    exit: [32.57, 30.64],   // near Sinai (Asia side)
  },
  // Bering Strait ferry (North America ↔ Asia)
  AMERICAS_ASIA: {
    entry: [-168.98, 65.7], // near Nome, Alaska
    exit: [169.0, 65.7],    // near Chukotka, Russia
  }
};

// Decide which ferry to use based on location
let ferry = null;
if (lon < -25) {
  ferry = FERRIES.AMERICAS_ASIA;
} else if (lat < 40 && lat > -40 && lon > -20 && lon < 40) {
  ferry = FERRIES.AFRICA_EURASIA;
}

if (ferry) {
  const ferryLine = turf.lineString([ferry.entry, ferry.exit], {
    properties: { virtual: true, name: "Virtual Ferry" }
  });

  // Build combined route (start → ferry → Rome)
  const combined = turf.featureCollection([start, ferryLine, rome]);

  // Draw visually
  if (routeLayer) map.removeLayer(routeLayer);
  routeLayer = L.geoJSON(combined, {
    style: f =>
      f.properties && f.properties.virtual
        ? { color: "blue", weight: 4, dashArray: "6,4" }
        : { color: "purple", weight: 5 }
  }).addTo(map);
}
      // 2) Request a driving route along roads to Rome
   // 2) Request a driving route along roads to Rome
let routeUrl = `${OSRM_BASE}/route/v1/driving/${snappedLon},${snappedLat};${ROME.lon},${ROME.lat}?overview=full&geometries=geojson&alternatives=false&steps=false`;
let routeResp = await fetch(routeUrl);
let routeJson = await routeResp.json();

// If OSRM fails or can't find a route, try virtual bridge paths
if (!(routeJson.code === "Ok" && routeJson.routes && routeJson.routes.length > 0)) {
  console.warn("No direct route found — trying virtual bridges…");

  const point = turf.point([lon, lat]);
  let bridge = null;

  // Rough continent check
  if (lat > 0 && lon < -30) bridge = { entry: BERING_W, exit: BERING_E }; // Americas
  if (lat < 30 && lon < 30 && lon > -20) bridge = { entry: ALSALAM_W, exit: ALSALAM_E }; // Africa
  if (bridge) {
    // Step 1: route to bridge entry
    const step1 = await fetch(`${OSRM_BASE}/route/v1/driving/${snappedLon},${snappedLat};${bridge.entry[0]},${bridge.entry[1]}?overview=full&geometries=geojson`);
    const step1json = await step1.json();

    // Step 2: virtual bridge (manual line)
    const bridgeLine = turf.lineString([bridge.entry, bridge.exit]);

    // Step 3: route from bridge exit to Rome
    const step3 = await fetch(`${OSRM_BASE}/route/v1/driving/${bridge.exit[0]},${bridge.exit[1]};${ROME.lon},${ROME.lat}?overview=full&geometries=geojson`);
    const step3json = await step3.json();

    if (step1json.code === "Ok" && step3json.code === "Ok") {
      const combined = turf.featureCollection([
        step1json.routes[0].geometry,
        bridgeLine,
        step3json.routes[0].geometry
      ]);
      routeLayer = L.geoJSON(combined, { style: { weight: 5, color: "purple" } }).addTo(map);
      map.fitBounds(routeLayer.getBounds(), { padding:[40,40] });
      routeLayer.bindPopup("Simulated bridge route to Rome").openPopup();
      return; // stop here, don't fall back
    }
  }
  throw new Error("No valid road or bridge route found.");
} else {
  // Normal successful route
  const routeGeojson = routeJson.routes[0].geometry;
  routeLayer = L.geoJSON(routeGeojson, { style: { weight: 5 } }).addTo(map);
  map.fitBounds(routeLayer.getBounds(), { padding:[40,40] });
  const distMeters = routeJson.routes[0].distance;
  const durSec = routeJson.routes[0].duration;
  const popupContent = `Road route to Rome — ${(distMeters/1000).toFixed(1)} km, ${(durSec/3600).toFixed(2)} hrs.`;
  routeLayer.bindPopup(popupContent).openPopup();
}
    } catch (err) {
      console.warn(err);
      // Great-circle fallback using turf
      if (fallbackLayer) map.removeLayer(fallbackLayer);
      const from = [lon, lat];
      const to = [ROME.lon, ROME.lat];
      // turf.greatCircle expects [lon,lat]
      const gc = turf.greatCircle(from, to, { npoints: 128, properties:{name:'greatcircle'} });
      fallbackLayer = L.geoJSON(gc, { style:{ weight:3, dashArray: '8 6' }}).addTo(map);
      map.fitBounds(fallbackLayer.getBounds(), { padding:[40,40] });
      // calculate great-circle distance
      const options = {units: 'kilometers'};
      const distance = turf.distance(turf.point(from), turf.point(to), options);
      fallbackLayer.bindPopup(`Great-circle path to Rome — distance ${distance.toFixed(1)} km.`).openPopup();
    }
  }
  </script>
</body>
</html>