<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Way to Rome</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html,body,#map { height:100%; margin:0; }
    .topbar {
      position: absolute; left:10px; top:10px; z-index:1000;
      background: rgba(255,255,255,0.9); padding:8px 10px; border-radius:6px;
      font-family:system-ui,Segoe UI,Roboto; font-size:14px;
    }
    button { margin-left:6px; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="topbar">
    Click anywhere on the map (or use geolocation) → follow the road to Rome.
    <button id="locBtn">Use my location</button>
    <button id="clearBtn">Clear</button>
  </div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
  // === CONFIG ===
  // Rome coordinates — city center (can be tuned)
  const ROME = { lat: 41.902782, lon: 12.496366 };
  // OSRM public server endpoints (example); for production consider self-host or paid API
  const OSRM_BASE = "https://router.project-osrm.org";
  // === MAP INIT ===
  const map = L.map('map').setView([20, 0], 2);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19, attribution: '© OpenStreetMap'
  }).addTo(map);
  const romeMarker = L.marker([ROME.lat, ROME.lon]).addTo(map).bindPopup("Rome (city center)").openPopup();
  let userMarker, routeLayer, fallbackLayer;
  // Helper: clear layers
  function clear() {
    if (userMarker) { map.removeLayer(userMarker); userMarker = null; }
    if (routeLayer) { map.removeLayer(routeLayer); routeLayer = null; }
    if (fallbackLayer) { map.removeLayer(fallbackLayer); fallbackLayer = null; }
  }
  document.getElementById('clearBtn').onclick = clear;
  // Click to select start
  map.on('click', async (e) => {
    await handlePoint(e.latlng.lat, e.latlng.lng);
  });
  // Geolocation button
  document.getElementById('locBtn').onclick = () => {
    if (!navigator.geolocation) return alert("Geolocation not supported.");
    navigator.geolocation.getCurrentPosition(
      pos => handlePoint(pos.coords.latitude, pos.coords.longitude),
      err => alert("Couldn't get location: " + err.message)
    );
  };
  // Main flow: snap to road -> request route -> draw or fallback
  async function handlePoint(lat, lon) {
    clear();
    userMarker = L.marker([lat, lon]).addTo(map).bindPopup("Selected point").openPopup();
    map.setView([lat, lon], 6);
    try {
      // 1) Snap to nearest road (OSRM nearest)
      const nearestResp = await fetch(`${OSRM_BASE}/nearest/v1/driving/${lon},${lat}?number=1`);
      if (!nearestResp.ok) throw new Error("Nearest API failed");
      const nearestJson = await nearestResp.json();
      if (!nearestJson.waypoints || nearestJson.waypoints.length === 0) {
        throw new Error("No road nearby to snap to.");
      }
      const snapped = nearestJson.waypoints[0].location; // [lon, lat]
      const snappedLat = snapped[1], snappedLon = snapped[0];
      // show snapped marker
      const snappedMarker = L.circleMarker([snappedLat, snappedLon], { radius:6, color:'green' })
        .addTo(map).bindPopup("Snapped to nearest road").openPopup();
      // 2) Request a driving route along roads to Rome
      // OSRM route format: /route/v1/driving/{lon},{lat};{lon},{lat}
      const routeUrl = `${OSRM_BASE}/route/v1/driving/${snappedLon},${snappedLat};${ROME.lon},${ROME.lat}?overview=full&geometries=geojson&alternatives=false&steps=false`;
      const routeResp = await fetch(routeUrl);
      if (!routeResp.ok) throw new Error("Route request failed");
      const routeJson = await routeResp.json();
      if (routeJson.code === "Ok" && routeJson.routes && routeJson.routes.length > 0) {
        const routeGeojson = routeJson.routes[0].geometry; // geojson LineString
        routeLayer = L.geoJSON(routeGeojson, {
          style: { weight: 5 }
        }).addTo(map);
        // Fit to route bounds
        map.fitBounds(routeLayer.getBounds(), { padding:[40,40] });
        // Show summary popup
        const distMeters = routeJson.routes[0].distance;
        const durSec = routeJson.routes[0].duration;
        const popupContent = `Road route to Rome — distance ${(distMeters/1000).toFixed(1)} km, time ${(durSec/3600).toFixed(2)} hrs.`;
        routeLayer.bindPopup(popupContent).openPopup();
      } else {
        // No valid road route — draw great-circle fallback
        throw new Error("No road route available, falling back to great-circle.");
      }
    } catch (err) {
      console.warn(err);
      // Great-circle fallback using turf
      if (fallbackLayer) map.removeLayer(fallbackLayer);
      const from = [lon, lat];
      const to = [ROME.lon, ROME.lat];
      // turf.greatCircle expects [lon,lat]
      const gc = turf.greatCircle(from, to, { npoints: 128, properties:{name:'greatcircle'} });
      fallbackLayer = L.geoJSON(gc, { style:{ weight:3, dashArray: '8 6' }}).addTo(map);
      map.fitBounds(fallbackLayer.getBounds(), { padding:[40,40] });
      // calculate great-circle distance
      const options = {units: 'kilometers'};
      const distance = turf.distance(turf.point(from), turf.point(to), options);
      fallbackLayer.bindPopup(`Great-circle path to Rome — distance ${distance.toFixed(1)} km.`).openPopup();
    }
  }
  // center map to show world and Rome
  map.once('load', () => {
    map.setView([20, 0], 2);
  });
  </script>
</body>
</html>